# Class

클래스와 구조체는 겉으로 보기에 굉장히 닮았다. 참고로 구조체는 클래스의 일종이다.
>클래스
>>구조체

차이점이 있다면 클래스 내 선언한 함수가 아닌 영역에선 클래스 변수를 선언할 수 없다.
```
Class Car
{
  char gamerID[CAR_CONST::ID_LEN];
  int fuelGauge;
  int curSpeed;

  void ShowCarState(){ ``` }
  void Accel() { ``` }
  void Break() { ``` }
};

int main(void)
{
  Car run99 {"run99", 100, 0};    // 틀린문장이다
}
```

위 클래스변수를 run99 {"run99", 100, 0}; 으로 클래스 내에 선언된 함수가 아닌


다른 영역(여기선 main함수)에서 변수를 초기화 하는것은 불가능하다.

```c++
int main(void)
{
  Car run99;
}
```

우리는 이런 식으로 main함수에서 run99를 생성할 수 있는데 이를 **객체** 라 한다.

물론 객체 내의 변수를 초기화 하려면 클래스 내 함수에서 변수를 선언해야 한다.

## 접근제어 지시자의 종류
- public: 어디서든 접근허용
- protected: 상속관계에 놓여있을 때, 유도 클래스에서의 접근 허용
- private 클래스 내(클래스 내에 정의된 함수)에서만 접근허용

~~아직까지는 상속을 배우지 않아서, protected 설명생략~~

private 는 주로 클래스 내 멤버변수를 선언하는 영역이고

public 은 주로 클래스 내 멤버함수를 선언하는 영역이다.

## 클래스를 사용하는 이유

#### 1. 객체(Object)의 정리에 용이하다.

>게임을 만드는 툴인 유니티를 사용할 때를 생각해보면
>
> 스크립트를 만들면 항상 class 안에 템플릿이 주어진다. GameManager.C# 이라던지, BoardManager.C# 처럼 게임 전반을 아우르는 큰 스크립트도 존재하지만, 대부분 Object
하나에 스크립트 하나를 넣는다.
>
>예를 들어, enemy 하나를 만들면 그 enemy 안에 스크립트를 하나 넣어준다. 그 스크립트는 클래스로 이루어져있고, 멤버변수로 enemy의 걷기 속도, 달리기 속도 등을 지정할 수 있고,
멤버함수로는 player와 접촉 시 player의 HP를 1 감소시키거나, 끊임없이 어느 지점을 배회하게 만들 수 있다.

이렇게 클래스 하나에 객체(enemy)가 가져야 할 변수와 행해야 할 행동을 모아놓는다면, 보기에도 너무 편하다. 만일 객체가 오류가 난다면 다른 곳을 손본 필요 없이 그 객체의 클래스만 확인해주면 되기 때문이다. 이렇게 정리가 빠르고 한눈에 들어온다는 장점이 가장 크다.

#### 2. 정보 은닉
 프로그래머도 인간이기 때문에, 코드 삽입 중 실수를 할 수 있다. 변하면 안되는 값인데, 실수로 변수입력을 잘못해서 원하는 결과와 다른 결과를 이끌어낼 수도 있다.
 >예를 들면, 출금을 30,000원이라 적어야 하는데 실수로 300,000원 이라고 적어서 코드를 돌리면 전혀 예상못한 금액이 나올 수도 있다. 이 실수를 인지못한 개발자가 상용화시킨다면, 큰 손실을 초래하게 될 것이다.

 따라서 프로그래머의 실수에도 대처해야하기 때문에 만들어진 개념이며, 제한된 방법으로의 접근만 허용을 해서 잘못된 값이 저장되지 않도록 도와야 하고, 또 실수를 했을 때, 실수가 쉽게 발견되도록 해야 한다.

클래스 내 정보은닉으로 private 접근제어 지시자를 사용하는 것이 대표적인 예다.

#### 3. 캡슐화
경험 많은 객체지향 프로그래머를 구분하는 첫 번째 기준은 캡슐화이다. 캡슐화는 일관되게 적용할 수 있는 단순한 개념이 아니고, 구현하는 프로그램의 성격과 특성에 따라서 적용하는 범위가 달라지는, 흔히 하는 말로 **정답이란 딱히 없는 개념** 이기 때문이다. 순전히 개발자의 역량에 달려있는 파트이다.

>예를 들면, 드릴을 예로 들자.
>
>드릴로 콘크리트를 뚫을 수도 있고, 철판을 뚫을 수도 있다. 콘크리트용 드릴과 철판용 드릴을 따로 사야 할 필요가 있을까? 하나의 드릴에 그때 그때 상황에 맞는 날로 바꿔서 사용하면 여러모로 다양하게 사용할 수 있을 것이다.
>
>이것이 캡슐화하는 이유인데, 날을 하나의 객체(캡슐)로 본다면, 드릴을 새로 바꾸어도 날은 그대로 사용 가능하고, 반대로 하나의 드릴에 날만 교체하여 사용할 수도 있다. 캡슐화는 개발자 편리하게 사용하기 위해 만들어진 개념이다.
>
>참고자료: https://kin.naver.com/qna/detail.nhn?d1id=1&dirId=1040101&docId=115497254&qb=7KCV67O07J2A64uJ6rO8IOy6oeyKkO2ZlA==&enc=utf8&section=kin&rank=1&search_sort=0&spq=0&pid=T08pxspVuERssslgQ14sssssted-375468&sid=zYDQpBEjXCu3SIwfvWehyw%3D%3D
