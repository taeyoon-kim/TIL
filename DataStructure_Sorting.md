# Sorting(정렬)
- - -
## 정렬의 소개
정렬은 __소팅(sorting)__ 이라고도 한다. 흔히 __소팅 알고리즘__ 이라고 부른다.

정렬은 물건을 크기순으로 오름차순(ascending order)이나 내림차순(descending order)으로 나열하는 것을 의미한다.

정렬은 자료 탐색에 있어서 필수적이다. 예를 들면, 영어 사전은 알파벳 순으로 잘 정렬되어있기 때문에 쉽게 찾을 수 있다. 또는 네이버쇼핑은 최저가를 가장 위에 띄워주기 때문에 값싼 제품을 쉽게 찾을 수 있다.

나는 정렬 알고리즘을 크게 __8개__ 를 제시하겠다. 뭐가 좋고 뭐가 나쁘고를 객관적으로 판단할 수는 없다. 프로그램 수행 환경에 따라 다르다. _만일 자료의 양이 굉장히 방대하다면 복잡하지만 효율적인 알고리즘 사용이 효과적이고, 자료의 양이 적다면 간단하고 명료한 알고리즘을 사용하는 것이 효과적이다._

정렬 알고리즘을 평가하는 효율성의 기준으로는 정렬을 위해 필요한 __비교 연산의 횟수__ 와 __이동 연산의 횟수__ 이다. 이들 횟수를 정확하게 구하기는 힘들기 때문에 __빅오 표기법__ 을 이용하여 근사적으로 표현한다.

또한, 정렬을 분류하는 기준으론 2가지를 더 들 수 있다.
- 내부 정렬(internal sorting)과 외부 정렬(external sorting)
  ```
  내부 정렬 : 모든 데이터가 주기억장치(램)에 저장된 상태에서 정렬하는 것
  외부 정렬 : 외부 기억장치(하드디스크)와 주기억장치 둘 다 정렬하는 것

  우리는 <<내부 정렬>>만 다룬다고 알면 된다.
  ```
- 안정성(stability)
  ```
  정렬 전 case
  : 30 30 10 20
  정렬 후 case
  : 10 20 30 30

  눈으로 보기엔 잘 정리된 것 같지만 같은 key를 가진 레코드들의 순서가
  정렬 후에 아래와 같이 바뀌게 될 수도 있다.

  정렬 전 case
  : 30(1) 30(2) 10(3) 20(4)              //순서 확인을 위해 번호 부여함
  정렬 후 case
  : 10(3) 20(4) 30(2) 30(1)              //두 개의 30의 위치가 바뀐 것 확인!

  위와 같은 경우를 안정성을 충족하지 못한다고 한다.
  물론 반대의 경우엔 안정성을 충족한다고 한다.
  ```

  ★모든 데이터는 1차원 배열에 무작위로 저장되었다고 가정하자★
- - -
## 1. 선택 정렬(selection sort)

가장 이해하기 쉬운 정렬이다. 말 그대로 선택을 통해 하나씩 정렬해나가는 알고리즘이다.
 1. 전체에서 가장 작은 값을 맨 앞의 값과 바꾼다.
 2. 그 다음으로 작은 값을 두 번째 값과 바꾼다.
 3. 이런 식으로 정렬을 진행한다.

```c
#define SWAP (x, y, t) ( (t)=(x), (x)=(y), (y)=(t) )

void selection_sort(int list[], int n)
{
  int i, j, least, temp;
  for(i=0; i<n-1; i++) {
    least = i;
    for(j = i + 1; j<n; j++) {
      if(list[j]<list[least])
        least = j;
      }
    swap(list[i], list[least], temp);
  }
}
```
## 2. 삽입 정렬(insertion sort)

선택 정렬과 비슷한듯 다르다. 앞에서부터 하나씩 하나씩 맞는 위치에 삽입한다.
1. arr[1]부터 시작한다. arr[0]은 이미 정렬되어 있다고 볼 수 있다.
2. arr[1]이 arr[0]보다 작으면 그 앞에 삽입, 크면 그 뒤에 삽입한다.
3. arr[2]는 arr[0], arr[1] 과 비교하여 알맞은 정렬 위치에 삽입한다.
4. 이런 식으로 정렬을 진행한다.
